# -*- coding: utf-8 -*-
"""
Created on Mon Jun  1 11:34:32 2020

@author: Ryan
"""

import copy
import itertools
from scipy.linalg import null_space
#import tkinter as tk
#I intend to make a GUI that makes this program easy to use, but I haven't gotten to it yet
import numpy as np
import networkx as nx
#It must seem a bit strange that I am importing networkx when I am making a program that is so similar to it! I use networkx here only to draw the graph based on an adjacency matrix generated by my homemade function..

class Graph:
    
    def __init__(self,name):
        
        self.name = name
        self.vertices = []
        self.edges = []
        self.connected_to = []
        #"connected_to" tells you what other graphs your graph has an edge connecting it to.
        
    def add_vertex(self,node):
        '''Adds a vertex to your graph'''
        self.vertices.append(node)
    
    def add_vertices(self,list_of_nodes):
        '''adds a bunch of vertices all at once'''
        for node in list_of_nodes:
            Node(str(node), self)
    
    def add_edge(self,edge):
        '''Adds an edge to your graph'''
        if edge.node1 != edge.node2 and edge.node1 not in edge.node2.neighbors:
            self.edges.append(edge)
      
            edge.node1.degree += 1
            edge.node2.degree += 1
            
            edge.node2.neighbors.append(edge.node1)
            edge.node1.neighbors.append(edge.node2)
            
            edge.node2.cnctd.append(edge.node1)
            edge.node1.cnctd.append(edge.node2)

            if edge.node1.graph != edge.node2.graph:
                edge.node1.graph.connected_to.append(edge.node2.graph)
                edge.node2.graph.connected_to.append(edge.node1.graph)
                
    def add_edges(self, list_of_tuples):
        '''adds a bunch of edges at once, takes tuples of endpoints'''
        for tup in list_of_tuples:
            Graph.add_edge(self, Edge(tup[0],tup[1]))
            
    
    def delete_edge(self,edge):
        '''deletes the indicated edge'''
        
        edge.node1.degree += -1
        edge.node1.neighbors.remove(edge.node2)
        
        edge.node2.degree += -1
        edge.node2.neighbors.remove(edge.node1)
        
        self.edges.remove(edge)
        
        if edge.node1.graph != edge.node2.graph:
            edge.node2.graph.edges.remove(edge)
    
    def clear_edges(self):
        '''deletes all edges in a graph'''
        for edge in self.edges:
            edge.node1.degree += -1
            edge.node1.neighbors.remove(edge.node2)
        
            edge.node2.degree += -1
            edge.node2.neighbors.remove(edge.node1)
        
        self.edges = []
        
    def print_neighbors(self):
        '''prints all of the vertices in a graph, along with each vertex's neighbors'''
        print('Original neighbors:')
        print('------------')
        for vtx in self.vertices:
            print(vtx.name+"'s neighbors are:")
            print('------')
            for neighbor in vtx.neighbors:
                print(neighbor.name)

                print("_______________")
        print('------------')

        
    def print_edges(self):
        '''Prints all of the end nodes of each edge of your graph'''
        print('ORIGINAL')
        for edge in self.edges:
            print(edge.node1.name)
            print(edge.node2.name)
            print('-------------')
        print('******************************************************')
            
    def give_info(self):
        '''tells you about your graph'''
                
        print("There are",len(self.vertices),"vertices")
        print("There are",len(self.edges),"edges")
        print("This graph is connected to",self.connected_to)
        Graph.is_this_a_tree(self)
        
    def find_complement(self):
        '''Finds the complement graph to yours'''
        
        self.complement = copy.deepcopy(self)
        pairs_of_vertices = list(itertools.combinations(self.complement.vertices, 2))
                
        for g in self.complement.connected_to:
            self.complement.connected_to.remove(g)
            
        Graph.clear_edges(self.complement)
                    
        for pair in pairs_of_vertices:
            if pair[0] not in pair[1].cnctd:
                Graph.add_edge(self.complement, Edge(pair[0],pair[1]))
        
        
        return self.complement
                
    def degree_matrix(self):
        '''Finds the degree matrix of the input graph'''
        array = []
        for vertex in self.vertices:
            array.append(vertex.degree)
        array = np.array(array)
        degree_mat = np.diag(array)
        return degree_mat
        
    def adjacency_matrix(self):
        '''Finds the adjacency matrix of the graph'''
        pairs_of_vertices = list(itertools.product(self.vertices, repeat=2))   
        edge_ends = [(edge.node1, edge.node2) for edge in self.edges]
        rows = []
        
        for node in self.vertices:
            row = []
            
            for pair in pairs_of_vertices:

                    if pair[0] == node:
                        
                        if pair in edge_ends:
                            row.append(1)
                        else:
                            row.append(0)

            rows.append(row)
        adjacency_mat = np.array(rows)
        adjacency_mat = adjacency_mat + adjacency_mat.transpose()
        return adjacency_mat
    
    def laplacian(self):
        '''Finds the laplacian matrix of the input graph'''
        lap = Graph.degree_matrix(self) - Graph.adjacency_matrix(self)
        return lap
    
    def spanning_trees(self):
        '''Uses Kirchhoff's theorem to calculate the # of spanning trees'''
        l = Graph.laplacian(self)
        l_prime = np.delete(l,1,0)
        l_prime = np.delete(l_prime,1,1)
        trees = np.linalg.det(l_prime)
        print( 'The number of spanning trees is', int(round(trees,0)))
        return(int(round(trees,0)))

    def number_of_components(self):
        '''Uses the laplacian to find how many separate components there are in your graph'''
        null = null_space(Graph.laplacian(self))
        dim_of_null = null.shape[1]
        
        return dim_of_null
            
    def is_this_a_tree(self):
        '''tells you whether your graph is a true (outputs Boolean)'''
        if Graph.spanning_trees(self) == 1:
            return True
        
    def paths_of_length_k(self,node1,node2,k):
        '''Finds the number of paths of length k between two nodes'''
        counter = 1
        adj_mat_k = Graph.adjacency_matrix(self)
        n1_row = self.vertices.index(node1)
        n2_column = self.vertices.index(node2)
        
        if k == 1:

            return Graph.adjacency_matrix(self)[n1_row][n2_column]
        
        elif k > 1:
            
            while counter < k:
                
                adj_mat_k = np.dot(adj_mat_k, Graph.adjacency_matrix(self))
                counter += 1
                
            return adj_mat_k[n1_row][n2_column]
        
    def draw(self):
        '''draws the graph using nx'''
        g = nx.from_numpy_matrix(np.array(Graph.adjacency_matrix(self)))
             
        nx.draw(g)    
                            
                
            
class Node:
    
    def __init__(self,name,graph):
        #initiating a node automatically adds it to the chosen graph
        self.name = name
        self.graph = graph
        Graph.add_vertex(self.graph,self)
        self.degree = 0
        self.neighbors = []
        self.cnctd = []

class Edge:
    
    def __init__(self, node1, node2, weight = 1):
        #initiating an edge adds it automatically to the graphs of your endpoints.

        self.node1 = node1
        self.node2 = node2        
        self.weight = weight
            
        Graph.add_edge(self.node1.graph, self)
            
    def delete_edge(self):
        '''deletes the indicated edge'''
        
        self.node1.graph.edges.remove(self)
        
        if self.node1.graph != self.node2.graph:
            self.node2.graph.edges.remove(self)
        
        self.node1.degree += -1
        self.node1.neighbors.remove(self.node2)
        
        self.node2.degree += -1
        self.node2.neighbors.remove(self.node1)



             
        
G = Graph('G')

A = Node('A',G)
B = Node('B',G)
C = Node('C',G)
D = Node('D',G)
E = Node('E',G)
F = Node('F',G)
h = Node('h', G)

H = Edge(A,B)
O = Edge(B,C)
Y = Edge(A,F)
R = Edge(D,E)
L = Edge(A,C)
o = Edge(A,D)





'''user_graph = Graph('user_graph')

root = tk.Tk()
label = tk.Label(root, text='Input names of vertices:')

label.grid(row=0, column=0)




e = tk.Entry(root)
e.grid(row=1, column = 0)

e.get()
new_user_node = Node(e.get, user_graph)


button1 = tk.Button(root,text = 'Find Complement', command=Graph.find_complement(user_graph))

button1.grid(row=20, column = 0)


root.mainloop()'''







